<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZAFER: Osmanlƒ± Kƒ±lƒ±cƒ±</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { overflow: hidden; background: #1a0f0a; font-family: 'Georgia', serif; }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #3d2817 0%, #2a1a10 100%);
            cursor: crosshair;
        }
        
        .ui-panel {
            position: fixed;
            background: rgba(139, 0, 0, 0.9);
            border: 2px solid #D4AF37;
            border-radius: 8px;
            color: #D4AF37;
            padding: 10px 15px;
            font-weight: bold;
            pointer-events: none;
        }
        
        #healthBar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #D4AF37;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(to right, #228B22, #32CD32);
            width: 100%;
            transition: width 0.3s;
        }
        
        #scorePanel {
            top: 10px;
            left: 10px;
        }
        
        #wavePanel {
            top: 10px;
            right: 10px;
        }
        
        /* Mobil Kontroller */
        #joystick-zone {
            position: fixed;
            bottom: 80px;
            left: 30px;
            width: 120px;
            height: 120px;
            display: none;
            z-index: 100;
        }
        
        .joystick-base {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255,255,255,0.1);
            border: 3px solid rgba(212,175,55,0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .joystick-stick {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #D4AF37, #B8860B);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        #mobile-controls {
            position: fixed;
            bottom: 80px;
            right: 30px;
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }
        
        .mobile-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid #D4AF37;
            background: rgba(139,0,0,0.8);
            color: #D4AF37;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .mobile-btn:active { transform: scale(0.95); background: rgba(180,0,0,0.9); }
        
        #btnAttack { background: linear-gradient(135deg, #8B0000, #600000); }
        #btnBlock { background: linear-gradient(135deg, #2E5C38, #1a3d25); font-size: 24px; }
        
        #startScreen, #gameOverScreen {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        #startScreen h1 {
            font-size: 48px;
            color: #D4AF37;
            text-shadow: 0 0 20px rgba(212,175,55,0.5);
            margin-bottom: 10px;
        }
        
        .btn-start {
            background: linear-gradient(to bottom, #D4AF37, #B8860B);
            border: none;
            padding: 20px 50px;
            font-size: 20px;
            font-weight: bold;
            color: #1a0000;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 30px;
        }
        
        .hidden { display: none !important; }
        
        .damage-text {
            position: absolute;
            color: #ff4444;
            font-weight: 900;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }
        
        @keyframes floatUp {
            to { transform: translateY(-40px); opacity: 0; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="healthBar"><div id="healthFill"></div></div>
    
    <div class="ui-panel" id="scorePanel">
        <div>‚öîÔ∏è <span id="score">0</span></div>
        <div style="font-size: 12px; color: #aaa;">Osmanlƒ±: <span id="allyCount">5</span></div>
    </div>
    
    <div class="ui-panel" id="wavePanel">
        <div>Dalga <span id="wave">1</span></div>
        <div style="font-size: 12px; color: #aaa;">Ha√ßlƒ±: <span id="enemyCount">0</span></div>
    </div>
    
    <!-- Mobil Kontroller -->
    <div id="joystick-zone">
        <div class="joystick-base"></div>
        <div class="joystick-stick" id="joystickStick"></div>
    </div>
    
    <div id="mobile-controls">
        <div class="mobile-btn" id="btnBlock">üõ°Ô∏è</div>
        <div class="mobile-btn" id="btnAttack">‚öîÔ∏è</div>
    </div>
    
    <div id="startScreen">
        <h1>‚öîÔ∏è ZAFER</h1>
        <p style="color: #888; margin-bottom: 20px;">Osmanlƒ± Kƒ±lƒ±cƒ±</p>
        <div style="color: #666; font-size: 14px; text-align: center; line-height: 1.8;">
            <p>5 Osmanlƒ± Yeni√ßeri vs Dalga Dalga Ha√ßlƒ± Ordusu</p>
            <p id="pcControls" style="margin-top: 10px;">WASD: Hareket | SOL TIK: Saldƒ±rƒ± | SHIFT: Blok</p>
            <p id="mobileControls" class="hidden" style="margin-top: 10px;">Joystick: Hareket | Butonlar: Saldƒ±rƒ±/Blok</p>
        </div>
        <button class="btn-start" onclick="startGame()">SAVA≈ûA BA≈ûLA</button>
    </div>
    
    <div id="gameOverScreen" class="hidden">
        <h1 style="font-size: 36px; color: #888; margin-bottom: 20px;">≈ûEHADET</h1>
        <p style="color: #D4AF37; font-size: 24px;">Skor: <span id="finalScore">0</span></p>
        <button class="btn-start" onclick="location.reload()">TEKRAR DENE</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // K√º√ß√ºk oyun alanƒ± - 1200x900
        const WORLD_WIDTH = 1200;
        const WORLD_HEIGHT = 900;
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Cihaz tespiti
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        if (isMobile) {
            document.getElementById('mobileControls').classList.remove('hidden');
            document.getElementById('pcControls').classList.add('hidden');
            document.getElementById('joystick-zone').style.display = 'block';
            document.getElementById('mobile-controls').style.display = 'flex';
        }
        
        // Oyun durumu
        let gameState = 'start';
        let score = 0;
        let wave = 1;
        let particles = [];
        let texts = [];
        
        // Input
        const keys = {};
        const mouse = { x: 0, y: 0, down: false };
        const joystick = { active: false, x: 0, y: 0, originX: 0, originY: 0 };
        
        // PC kontrolleri
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') player.attack();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', () => {
            mouse.down = true;
            player.attack();
        });
        canvas.addEventListener('mouseup', () => mouse.down = false);
        
        // Mobil joystick
        const joystickZone = document.getElementById('joystick-zone');
        const joystickStick = document.getElementById('joystickStick');
        
        joystickZone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickZone.getBoundingClientRect();
            joystick.originX = rect.left + rect.width / 2;
            joystick.originY = rect.top + rect.height / 2;
            joystick.active = true;
            updateJoystick(touch.clientX, touch.clientY);
        });
        
        joystickZone.addEventListener('touchmove', e => {
            e.preventDefault();
            if (joystick.active) updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
        });
        
        joystickZone.addEventListener('touchend', e => {
            e.preventDefault();
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            joystickStick.style.transform = `translate(-50%, -50%)`;
        });
        
        function updateJoystick(clientX, clientY) {
            const maxDist = 35;
            let dx = clientX - joystick.originX;
            let dy = clientY - joystick.originY;
            const dist = Math.hypot(dx, dy);
            
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            
            joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joystick.x = dx / maxDist;
            joystick.y = dy / maxDist;
        }
        
        // Mobil butonlar
        const btnAttack = document.getElementById('btnAttack');
        const btnBlock = document.getElementById('btnBlock');
        
        btnAttack.addEventListener('touchstart', e => {
            e.preventDefault();
            player.attack();
        });
        
        btnBlock.addEventListener('touchstart', e => {
            e.preventDefault();
            player.blocking = true;
        });
        btnBlock.addEventListener('touchend', e => {
            e.preventDefault();
            player.blocking = false;
        });
        
        // Sƒ±nƒ±flar
        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                const a = Math.random() * Math.PI * 2;
                this.vx = Math.cos(a) * speed;
                this.vy = Math.sin(a) * speed;
                this.size = size;
                this.life = life;
                this.maxLife = life;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3;
                this.life--;
                this.size *= 0.95;
            }
            
            draw() {
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        class Entity {
            constructor(x, y, radius, speed, team) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.speed = speed;
                this.team = team; // 'ottoman' veya 'cross'
                this.angle = 0;
                this.health = 100;
                this.maxHealth = 100;
                this.attacking = false;
                this.attackCooldown = 0;
                this.blocking = false;
                this.hitFlash = 0;
                this.target = null;
            }
            
            takeDamage(amount) {
                if (this.blocking && Math.random() > 0.5) {
                    showText(this.x, this.y - 30, "BLOK!", "#FFD700");
                    return;
                }
                
                this.health -= amount;
                this.hitFlash = 10;
                
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(this.x, this.y, '#8B0000', 5, 4, 30));
                }
                
                showText(this.x, this.y - 40, `-${amount}`, "#ff4444");
                
                if (this.health <= 0) this.die();
            }
            
            die() {
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(this.x, this.y, '#8B0000', 8, 5, 40));
                }
            }
            
            drawHealth() {
                const barW = 30;
                const hp = Math.max(0, this.health / this.maxHealth);
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - barW/2, this.y - this.radius - 12, barW, 5);
                ctx.fillStyle = hp > 0.5 ? '#0f0' : hp > 0.25 ? '#ff0' : '#f00';
                ctx.fillRect(this.x - barW/2, this.y - this.radius - 12, barW * hp, 5);
            }
        }
        
        class Player extends Entity {
            constructor() {
                super(WORLD_WIDTH/2, WORLD_HEIGHT/2, 20, 4, 'ottoman');
                this.maxHealth = 150;
                this.health = 150;
                this.damage = 30;
                this.attackRange = 70;
            }
            
            update() {
                // Hareket
                let dx = 0, dy = 0;
                
                if (isMobile && joystick.active) {
                    dx = joystick.x;
                    dy = joystick.y;
                } else {
                    if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
                    if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
                    if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
                    if (keys['KeyD'] || keys['ArrowRight']) dx = 1;
                    
                    if (dx !== 0 && dy !== 0) {
                        dx *= 0.707;
                        dy *= 0.707;
                    }
                }
                
                // PC'de fare y√∂n√º
                if (!isMobile) {
                    this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                } else if (dx !== 0 || dy !== 0) {
                    this.angle = Math.atan2(dy, dx);
                }
                
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                // Sƒ±nƒ±rlar
                this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y));
                
                // Blok
                this.blocking = keys['ShiftLeft'] || keys['ShiftRight'] || (isMobile && player.blocking);
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.hitFlash > 0) this.hitFlash--;
                if (this.attacking && this.attackCooldown <= 25) this.attacking = false;
            }
            
            attack() {
                if (this.attackCooldown > 0 || this.blocking) return;
                
                this.attacking = true;
                this.attackCooldown = 35;
                
                // Saldƒ±rƒ± arkƒ± √ßiz
                ctx.strokeStyle = 'rgba(255,215,0,0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.attackRange, this.angle - 0.6, this.angle + 0.6);
                ctx.stroke();
                
                // Hasar ver
                const targets = this.team === 'ottoman' ? enemies : allies;
                targets.forEach(e => {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    const angleTo = Math.atan2(e.y - this.y, e.x - this.x);
                    let diff = Math.abs(angleTo - this.angle);
                    if (diff > Math.PI) diff = 2 * Math.PI - diff;
                    
                    if (dist < this.attackRange && diff < 0.8) {
                        e.takeDamage(this.damage);
                        for (let i = 0; i < 3; i++) {
                            particles.push(new Particle(e.x, e.y, '#FFD700', 4, 3, 15));
                        }
                    }
                });
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // G√∂lge
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 25, 20, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // V√ºcut
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#D4AF37';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Sarƒ±k
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(0, -5, this.radius - 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Kƒ±lƒ±√ß
                const swing = this.attacking ? -0.7 : 0.3;
                ctx.rotate(swing);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(15, -3, 4, 35); // Bƒ±√ßak
                ctx.fillStyle = '#D4AF37';
                ctx.fillRect(13, 0, 8, 4); // Guard
                
                // Kalkan (blok)
                if (this.blocking) {
                    ctx.rotate(-swing);
                    ctx.fillStyle = 'rgba(212,175,55,0.8)';
                    ctx.beginPath();
                    ctx.arc(-18, 0, 14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#8B0000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.restore();
                
                if (this.hitFlash > 0) {
                    ctx.fillStyle = `rgba(255,0,0,${this.hitFlash/20})`;
                    ctx.fillRect(this.x - 25, this.y - 25, 50, 50);
                }
                
                this.drawHealth();
            }
        }
        
        class Ally extends Entity {
            constructor(x, y) {
                super(x, y, 18, 2.5, 'ottoman');
                this.maxHealth = 120;
                this.health = 120;
                this.damage = 20;
                this.attackRange = 60;
            }
            
            update() {
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.hitFlash > 0) this.hitFlash--;
                
                // En yakƒ±n d√º≈ümanƒ± bul
                let closest = null;
                let minDist = Infinity;
                
                enemies.forEach(e => {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDist) {
                        minDist = d;
                        closest = e;
                    }
                });
                
                if (closest) {
                    const angle = Math.atan2(closest.y - this.y, closest.x - this.x);
                    this.angle = angle;
                    
                    if (minDist > this.attackRange) {
                        this.x += Math.cos(angle) * this.speed;
                        this.y += Math.sin(angle) * this.speed;
                    } else if (this.attackCooldown <= 0) {
                        // Saldƒ±r
                        this.attacking = true;
                        this.attackCooldown = 40;
                        closest.takeDamage(this.damage);
                        setTimeout(() => this.attacking = false, 200);
                    }
                }
                
                // Sƒ±nƒ±rlar
                this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y));
            }
            
            die() {
                super.die();
                const idx = allies.indexOf(this);
                if (idx > -1) allies.splice(idx, 1);
                updateCounts();
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 22, 18, 7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#8B0000';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#D4AF37';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Sarƒ±k
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(0, -4, this.radius - 3, 0, Math.PI * 2);
                ctx.fill();
                
                // T√ºy
                ctx.fillStyle = '#C0392B';
                ctx.beginPath();
                ctx.ellipse(-12, -10, 3, 10, -0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Kƒ±lƒ±√ß
                const swing = this.attacking ? -0.6 : 0.2;
                ctx.rotate(swing);
                ctx.fillStyle = '#AAA';
                ctx.fillRect(12, -2, 3, 28);
                
                ctx.restore();
                
                if (this.hitFlash > 0) {
                    ctx.fillStyle = `rgba(255,255,255,${this.hitFlash/15})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                this.drawHealth();
            }
        }
        
        class Enemy extends Entity {
            constructor(x, y, type) {
                super(x, y, type === 'heavy' ? 22 : 18, type === 'heavy' ? 1.8 : 2.5, 'cross');
                this.type = type;
                this.maxHealth = type === 'heavy' ? 150 : 80;
                this.health = this.maxHealth;
                this.damage = type === 'heavy' ? 25 : 15;
                this.attackRange = 55;
            }
            
            update() {
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.hitFlash > 0) this.hitFlash--;
                
                // Hedef se√ß: Oyuncu veya yakƒ±n m√ºttefik
                let targets = [player, ...allies];
                let closest = null;
                let minDist = Infinity;
                
                targets.forEach(t => {
                    if (t.health <= 0) return;
                    const d = Math.hypot(t.x - this.x, t.y - this.y);
                    if (d < minDist) {
                        minDist = d;
                        closest = t;
                    }
                });
                
                if (closest) {
                    const angle = Math.atan2(closest.y - this.y, closest.x - this.x);
                    this.angle = angle;
                    
                    if (minDist > this.attackRange) {
                        this.x += Math.cos(angle) * this.speed;
                        this.y += Math.sin(angle) * this.speed;
                    } else if (this.attackCooldown <= 0) {
                        this.attacking = true;
                        this.attackCooldown = 45;
                        closest.takeDamage(this.damage);
                        setTimeout(() => this.attacking = false, 200);
                    }
                }
                
                // Sƒ±nƒ±rlar
                this.x = Math.max(this.radius, Math.min(WORLD_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(WORLD_HEIGHT - this.radius, this.y));
            }
            
            die() {
                super.die();
                const idx = enemies.indexOf(this);
                if (idx > -1) {
                    enemies.splice(idx, 1);
                    score += this.type === 'heavy' ? 20 : 10;
                    updateCounts();
                    
                    if (enemies.length === 0) {
                        wave++;
                        setTimeout(spawnWave, 1500);
                    }
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.radius + 5, this.radius, 7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = this.type === 'heavy' ? '#2F4F4F' : '#4A4A4A';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.type === 'heavy') {
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Kask
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.arc(0, -3, this.radius - 3, 0, Math.PI, true);
                ctx.fill();
                
                // Silah
                ctx.save();
                ctx.rotate(this.attacking ? -0.7 : 0.2);
                if (this.type === 'heavy') {
                    // Baltalƒ±
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(12, -5, 6, 25);
                    ctx.fillStyle = '#AAA';
                    ctx.beginPath();
                    ctx.moveTo(15, -20);
                    ctx.lineTo(25, -10);
                    ctx.lineTo(15, 0);
                    ctx.fill();
                } else {
                    // Kƒ±lƒ±√ßlƒ±
                    ctx.fillStyle = '#AAA';
                    ctx.fillRect(14, -35, 3, 35);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(12, 0, 7, 6);
                }
                ctx.restore();
                
                ctx.restore();
                
                if (this.hitFlash > 0) {
                    ctx.fillStyle = `rgba(255,255,255,${this.hitFlash/15})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                this.drawHealth();
            }
        }
        
        // Global deƒüi≈ükenler
        let player;
        let allies = [];
        let enemies = [];
        
        function showText(x, y, text, color) {
            const el = document.createElement('div');
            el.className = 'damage-text';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.color = color;
            el.textContent = text;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
        
        function updateCounts() {
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = wave;
            document.getElementById('allyCount').textContent = allies.length + 1; // + player
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('healthFill').style.width = (player.health / player.maxHealth * 100) + '%';
        }
        
        function spawnWave() {
            const enemyCount = 3 + wave * 2; // Dalga ba≈üƒ±na artan d√º≈üman
            
            for (let i = 0; i < enemyCount; i++) {
                const angle = (Math.PI * 2 * i) / enemyCount;
                const dist = 350 + Math.random() * 100;
                const type = Math.random() > 0.7 ? 'heavy' : 'normal';
                enemies.push(new Enemy(
                    WORLD_WIDTH/2 + Math.cos(angle) * dist,
                    WORLD_HEIGHT/2 + Math.sin(angle) * dist,
                    type
                ));
            }
            
            updateCounts();
        }
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            
            player = new Player();
            allies = [];
            enemies = [];
            score = 0;
            wave = 1;
            
            // 5 Osmanlƒ± yeni√ßeri
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5;
                allies.push(new Ally(
                    WORLD_WIDTH/2 + Math.cos(angle) * 80,
                    WORLD_HEIGHT/2 + Math.sin(angle) * 80
                ));
            }
            
            spawnWave();
            gameState = 'playing';
            gameLoop();
        }
        
        function gameOver() {
            gameState = 'gameover';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        function gameLoop() {
            if (gameState !== 'playing') return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Zemin
            ctx.fillStyle = '#3d2817';
            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            
            // Grid
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < WORLD_WIDTH; x += 100) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, WORLD_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y < WORLD_HEIGHT; y += 100) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(WORLD_WIDTH, y);
                ctx.stroke();
            }
            
            // Sƒ±nƒ±r
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            
            // G√ºncelle
            player.update();
            allies.forEach(a => a.update());
            enemies.forEach(e => e.update());
            
            particles = particles.filter(p => {
                p.update();
                return p.life > 0;
            });
            
            // √áiz (Y sƒ±ralamasƒ±)
            const all = [player, ...allies, ...enemies].filter(e => e.health > 0).sort((a, b) => a.y - b.y);
            all.forEach(e => e.draw());
            
            particles.forEach(p => p.draw());
            
            // Kamera takibi (oyuncu merkezli)
            const camX = player.x - canvas.width / 2;
            const camY = player.y - canvas.height / 2;
            
            // Canvas'ƒ± sƒ±nƒ±rla
            ctx.setTransform(1, 0, 0, 1, -Math.max(0, Math.min(camX, WORLD_WIDTH - canvas.width)), -Math.max(0, Math.min(camY, WORLD_HEIGHT - canvas.height)));
            
            updateCounts();
            
            if (player.health <= 0) gameOver();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Ba≈ülangƒ±√ß
        drawBackground();
        function drawBackground() {
            ctx.fillStyle = '#3d2817';
            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        }
    </script>
</body>
</html>
